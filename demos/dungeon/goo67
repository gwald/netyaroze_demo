# 1 "tuto7.c"
 


















# 1 "g:/program/psx/include.35/stdio.h" 1 3
 





















typedef unsigned int size_t;   


 




extern int printf(char *fmt, ...);  
extern int sprintf(char *buffer, char *fmt, ...);

extern char getc(int);		 
extern char getchar(void);
extern char *gets(char *);
extern void putc(char, int);	 
extern void putchar(char);
extern void puts(char *);





# 20 "tuto7.c" 2

# 1 "g:/program/psx/include.35/rand.h" 1 3
 


 











extern int  rand(void);
extern void srand(unsigned int);





# 21 "tuto7.c" 2

# 1 "c:/blackpsx/include/libps.h" 1 3
 











# 1 "g:/program/psx/include.35/sys/types.h" 1 3
 


 






 



 


 


 




typedef	unsigned char	u_char;



typedef	unsigned short	u_short;



typedef	unsigned int	u_int;



typedef	unsigned long	u_long;



typedef	unsigned short	ushort;		 

# 53 "g:/program/psx/include.35/sys/types.h" 3


typedef	struct	_physadr { int r[1]; } *physadr;
typedef	struct	label_t	{
	int	val[12];
} label_t;

typedef	struct	_quad { long val[2]; } quad;
typedef	long	daddr_t;
typedef	char *	caddr_t;
typedef	long *	qaddr_t;	 
typedef	u_long	ino_t;
typedef	long	swblk_t;






typedef	long	time_t;
typedef	short	dev_t;
typedef	long	off_t;
typedef	u_short	uid_t;
typedef	u_short	gid_t;




# 13 "c:/blackpsx/include/libps.h" 2 3


 



 
typedef struct {
	short x, y;		 
	short w, h;		 
} RECT;

typedef struct  {
	short	m[3][3];	 
	long    t[3];		 
} MATRIX;

typedef struct {		 
	long	vx, vy;
	long	vz, pad;
} VECTOR;
	
typedef struct {		 	
	short	vx, vy;
	short	vz, pad;
} SVECTOR;
	       
typedef struct {		 	
	u_char	r, g, b, cd;
} CVECTOR;
	       
typedef struct {
	VECTOR  scale;
	SVECTOR rotate;
	VECTOR  trans;
} GsCOORD2PARAM;

typedef struct _GsCOORDINATE2 {
	unsigned long flg;
	MATRIX  coord;
	MATRIX  workm;
	GsCOORD2PARAM *param;
	struct _GsCOORDINATE2 *super;
	struct _GsCOORDINATE2 *sub;
} GsCOORDINATE2;

typedef struct {
	MATRIX  view;
	GsCOORDINATE2 *super;
} GsVIEW2;

typedef struct {
	long    vpx, vpy, vpz;
	long    vrx, vry, vrz;
	long    rz;
	GsCOORDINATE2 *super;
} GsRVIEW2;

typedef struct {
	int     vx, vy, vz;
	unsigned char r, g, b;
} GsF_LIGHT;


typedef struct {
	unsigned p:24;
	unsigned char num:8;
} GsOT_TAG;

typedef struct {
	unsigned long length;
	GsOT_TAG *org;
	unsigned long offset;
	unsigned long point;
	GsOT_TAG *tag;
} GsOT;

typedef struct {
	unsigned long attribute; 
	GsCOORDINATE2 *coord2;	 
	unsigned long *tmd;
	unsigned long id;	 
} GsDOBJ2;

typedef struct {
	unsigned long attribute;
	short   x, y;
	unsigned short w, h;
	unsigned short tpage;
	unsigned char u, v;
	short   cx, cy;
	unsigned char r, g, b;
	short   mx, my;
	short   scalex, scaley;
	long    rotate;
} GsSPRITE;

typedef struct {
	unsigned char u, v;
	unsigned short cba;
	unsigned short flag;
	unsigned short tpage;
} GsCELL;

typedef struct {
	unsigned char cellw, cellh;
	unsigned short ncellw, ncellh;
	GsCELL *base;
	unsigned short *index;
} GsMAP;

typedef struct {
	unsigned long attribute;
	short   x, y;
	short   w, h;
	short   scrollx, scrolly;
	unsigned char r, g, b;
	GsMAP  *map;
	short   mx, my;
	short   scalex, scaley;
	long    rotate;
} GsBG;

typedef struct {
	unsigned long attribute;
	short   x0, y0;
	short   x1, y1;
	unsigned char r, g, b;
} GsLINE;

typedef struct {
	unsigned long attribute;
	short   x0, y0;
	short   x1, y1;
	unsigned char r0, g0, b0;
	unsigned char r1, g1, b1;
} GsGLINE;

typedef struct {
	unsigned long attribute;
	short   x, y;
	unsigned short w, h;
	unsigned char r, g, b;
} GsBOXF;

typedef struct {
	short   dqa;
	long    dqb;
	unsigned char rfc, gfc, bfc;
} GsFOGPARAM;

typedef struct {
	unsigned long pmode;
	short   px, py;
	unsigned short pw, ph;
	unsigned long *pixel;
	short   cx, cy;
	unsigned short cw, ch;
	unsigned long *clut;
} GsIMAGE;

typedef struct {
	short   offx, offy;
} _GsPOSITION;

typedef struct {
	u_long	tag;
	u_long	code[15];
} DR_ENV;
	       
typedef struct {
	RECT	clip;		 
	short	ofs[2];		 
	RECT	tw;		 
	u_short tpage;		 	
	u_char	dtd;		 
	u_char	dfe;		 
	u_char	isbg;		 
	u_char	r0, g0, b0;	 
	DR_ENV	dr_env;		 
} DRAWENV;
	       
typedef struct {
	RECT	disp;		 
	RECT	screen;		 
	u_char	isinter;	 
	u_char	isrgb24;	 
	u_char	pad0, pad1;	 
} DISPENV;


 
typedef struct {
	unsigned short left;     
	unsigned short right;    
} SndVolume;

 
typedef struct {
	u_char minute;		 
	u_char second;		 
	u_char sector;		 
	u_char track;		 
} CdlLOC;

typedef struct {
	CdlLOC	pos;		 
	u_long	size;		 
	char	name[16];	 
} CdlFILE;

struct EXEC {                   
	unsigned long pc0;      
	unsigned long gp0;      
	unsigned long t_addr;   
	unsigned long t_size;   
	unsigned long d_addr;   
	unsigned long d_size;   
	unsigned long b_addr;   
	unsigned long b_size;   
	unsigned long s_addr;
	unsigned long s_size;
	unsigned long sp,fp,gp,ret,base;
};

struct DIRENTRY {
	char name[20];
	long attr;
	long size;
	struct DIRENTRY *next;
	long head;
	char system[4];
};


 



 























 











 







 






















 



 



typedef unsigned char PACKET;

 


extern RECT CLIP2;		 
extern int GsLIGHT_MODE;	 
extern short PSDOFSX[2], PSDOFSY[2];	 
extern short PSDIDX;		 
extern u_long PSDCNT;		 
extern _GsPOSITION POSITION;	 
extern DRAWENV GsDRAWENV;	 
extern DISPENV GsDISPENV;	 
extern MATRIX GsLSMATRIX;	 
extern MATRIX GsWSMATRIX;	 
extern MATRIX GsLIGHTWSMATRIX;	 
extern MATRIX GsIDMATRIX;	 
extern MATRIX GsIDMATRIX2;	 
extern PACKET *GsOUT_PACKET_P;	 
extern u_long GsLMODE, GsLIGNR, GsLIOFF, GsNDIV;
extern u_long GsTON, GsDISPON;

extern int math_errno;

 



 
int VSync(int mode);
int VSyncCallback(void (*f)()) ;
extern DISPENV *PutDispEnv(DISPENV *env);
extern DRAWENV *PutDrawEnv(DRAWENV *env);
extern int ClearImage(RECT *rect, u_char r, u_char g, u_char b);
extern int DrawSync(int mode);
extern int FntOpen(int x, int y, int w, int h, int isbg, int n);
extern int KanjiFntOpen(int x, int y, int w, int h, int dx, int dy, int cx, int cy, int isbg, int n);
extern int Krom2Tim(u_char *sjis, u_long *taddr, int dx, int dy, int cdx, int cdy, u_int fg, u_int bg);
extern int LoadImage(RECT *rect, u_long *p);
extern int MoveImage(RECT *rect, int x, int y);
extern int ResetGraph(int mode);
extern int StoreImage(RECT *rect, u_long *p);
extern u_long *FntFlush(int id);
extern u_long *KanjiFntFlush(int id);
extern u_short GetClut(int x, int y) ;
extern u_short GetTPage(int tp, int abr, int x, int y) ;
extern void FntLoad(int tx, int ty);
extern void SetDispMask(int mask);
extern int FntPrint();
extern int KanjiFntPrint();
extern	void    GsInit3D(void);
extern	void    GsInitGraph(unsigned short x, unsigned short y, unsigned short intmode, unsigned short dith, unsigned short varmmode);
extern	void    GsMapModelingData(unsigned long *p);
extern	void    GsSetProjection(long h);
extern	int     GsSetFlatLight(int id, GsF_LIGHT * lt);
extern	void    GsSetLightMode(int mode);
extern	void    GsSetFogParam(GsFOGPARAM * fogparm);
extern	void    GsSetAmbient(long r, long g, long b);
extern	void    GsDrawOt(GsOT * ot);
extern	void    GsSetWorkBase(PACKET * outpacketp);
extern	void    GsSortObject4(GsDOBJ2 * objp, GsOT * ot, int shift, u_long * scratch);
extern	void    GsSortSprite(GsSPRITE * sp, GsOT * ot, unsigned short pri);
extern	void    GsSortFastSprite(GsSPRITE * sp, GsOT * ot, unsigned short pri);
extern	void    GsInitFixBg16(GsBG * bg, u_long * work);
extern	void    GsSortFixBg16(GsBG * bg, u_long * work, GsOT * otp, unsigned short pri);
extern	void    GsSortLine(GsLINE * lp, GsOT * ot, unsigned short pri);
extern	void    GsSortGLine(GsGLINE * lp, GsOT * ot, unsigned short pri);
extern	void    GsSortBoxFill(GsBOXF * bp, GsOT * ot, unsigned short pri);
extern	void    GsClearOt(unsigned short offset, unsigned short point, GsOT * otp);
extern	GsOT   *GsSortOt(GsOT * ot_src, GsOT * ot_dest);
extern	void    GsDefDispBuff(unsigned short x0, unsigned short y0, unsigned short x1, unsigned short y1);
extern	void    GsGetTimInfo(unsigned long *im, GsIMAGE * tim);
extern	void    GsSwapDispBuff(void);
extern	int     GsGetActiveBuff(void);
extern	void    GsSetDrawBuffClip(void);
extern	void    GsSetDrawBuffOffset(void);
extern	void    GsSetClip(RECT * clip);
extern	void    GsSetOffset(long x, long y);
extern	void    GsSetOrign(long x, long y);
extern	void    GsInitCoordinate2(GsCOORDINATE2 * super, GsCOORDINATE2 * base);
extern	void    GsGetLw(GsCOORDINATE2 * m, MATRIX * out);
extern	void    GsGetLs(GsCOORDINATE2 * m, MATRIX * out);
extern	void    GsGetLws(GsCOORDINATE2 * m, MATRIX * outw, MATRIX * outs);
extern	void    GsLinkObject4(unsigned long tmd_base, GsDOBJ2 * objp, int n);
extern	void    GsSetLightMatrix(MATRIX * mp);
extern	int     GsSetRefView2(GsRVIEW2 * pv);
extern	int     GsSetView2(GsVIEW2 * pv);
extern	void    GsSetLsMatrix(MATRIX * mp);
extern	void    GsSetClip2D(RECT * rectp);
extern	PACKET *GsGetWorkBase();
extern	void    GsSortClear(unsigned char r, unsigned char g , unsigned char b, GsOT *);
extern	void    GsScaleScreen(SVECTOR * scale);
extern MATRIX *MulMatrix0(MATRIX *m0,MATRIX *m1,MATRIX *m2);
extern VECTOR *ApplyMatrix(MATRIX *m,SVECTOR *v0,VECTOR *v1);
extern VECTOR *ApplyMatrixSV(MATRIX *m,SVECTOR *v0,SVECTOR *v1);
extern VECTOR *ApplyMatrixLV(MATRIX *m,VECTOR *v0,VECTOR *v1);
extern MATRIX *RotMatrix(SVECTOR *r,MATRIX *m);
extern MATRIX *RotMatrixX(long r,MATRIX *m);
extern MATRIX *RotMatrixY(long r,MATRIX *m);
extern MATRIX *RotMatrixZ(long r,MATRIX *m);
extern MATRIX *TransMatrix(MATRIX *m,VECTOR *v);
extern MATRIX *ScaleMatrix(MATRIX *m,VECTOR *v);
extern MATRIX *ScaleMatrixL(MATRIX *m,VECTOR *v);
extern MATRIX *TransposeMatrix(MATRIX *m0,MATRIX *m1);
extern MATRIX *CompMatrix(MATRIX *m0,MATRIX *m1,MATRIX *m2);
extern void PushMatrix();
extern void PopMatrix();
extern void gteMIMefunc(SVECTOR *otp, SVECTOR *dfp, long n, long p);

 
extern void  SsVabClose (short);          
extern short SsVabTransfer (unsigned char *, unsigned char *, short, short);
extern short SsSeqOpen (unsigned long*, short); 
extern void  SsSeqClose (short);                       
extern void  SsSeqPlay (short, char, short);    
extern void  SsSeqPause (short);                    
extern void  SsSeqReplay (short);                  
extern void  SsSeqStop (short);                   
extern void  SsSeqSetVol (short, short, short);  
extern void  SsSeqGetVol (short, short, short*, short*);
extern void  SsSeqSetNext (short, short);             
extern void  SsSeqSetRitardando (short, long, long);   
extern void  SsSeqSetAccelerando (short, long, long);  
extern void  SsSetMVol (short, short);              
extern void  SsGetMVol (SndVolume*);             
extern void  SsSetMute (char);                        
extern char  SsGetMute (void);                        
extern void  SsSetTempo (short, short, short);
extern short SsIsEos (short, short);
extern void  SsPlayBack (short, short, short);
extern void  SsSetSerialAttr (char, char, char);     
extern char  SsGetSerialAttr (char, char);           
extern void  SsSetSerialVol (char, short, short);    
extern void  SsGetSerialVol (char, SndVolume*); 
extern short SsUtKeyOn (short, short, short, short, short, short, short);
extern short SsUtKeyOff (short, short, short, short, short);
extern short SsUtPitchBend (short, short, short, short, short);
extern short SsUtChangePitch (short, short, short, short, short, short, short);
extern short SsUtSetVVol (short, short, short);
extern short SsUtGetVVol (short, short*, short*);
extern void  SsUtReverbOn (void);
extern void  SsUtReverbOff (void);
extern short SsUtSetReverbType (short);
extern short SsUtGetReverbType (void);
extern void  SsUtSetReverbDepth (short, short);
extern void  SsUtSetReverbFeedback (short);
extern void  SsUtSetReverbDelay (short);
extern void  SsUtAllKeyOff (short);

 
extern double pow(double, double);
extern double exp(double);
extern double log(double);
extern double log10(double);
extern double floor(double);
extern double ceil(double);
extern double fmod(double,double);
extern double modf(double,double *);
extern double sin(double);
extern double cos(double);
extern double tan(double);
extern double asin(double);
extern double acos(double);
extern double atan(double);
extern double atan2(double, double);
extern double sinh(double);
extern double cosh(double);
extern double tanh(double);
extern double sqrt(double);
extern double hypot(double, double);
extern double ldexp(double, int);
extern double frexp(double, int *);
extern double atof(char *);
extern double strtod(char *, char **);
extern int printf2(char *, ...);
extern int sprintf2(char *, char *, ...);

 
extern void GetPadBuf(volatile unsigned char **, volatile unsigned char **);
extern long GetRCnt(unsigned long);
extern long ResetRCnt(unsigned long);
extern long StartRCnt(unsigned long);
extern int open(char *, int);
extern int close(int);
extern int lseek(int, unsigned int, int);
extern int read(int, char *, int);
extern int write(int, char *, int);
extern struct DIRENTRY * firstfile(char *, struct DIRENTRY *);
extern struct DIRENTRY * nextfile(struct DIRENTRY *);
extern int delete(char *);
extern int format(char *);
extern int rename(char *, char *);
extern long LoadTest(char *, struct EXEC *);
extern long Load(char *, struct EXEC *);
extern long Exec(struct EXEC *, long, char **);
extern void FlushCashe(void);
extern long _get_errno(void);
extern int CdReadFile(char *file, u_long *addr, int nbyte);
extern int CdReadSync(int mode, u_char *result);
extern CdlFILE *CdSearchFile(CdlFILE *fp, char *name);
extern struct EXEC *CdReadExec(char *file);
extern int CdPlay(int mode, int *tracks, int offset);
extern void EnterCriticalSection(void);
extern void ExitCriticalSection(void);
extern long TestCard(long);

 



 

# 22 "tuto7.c" 2

# 1 "sincos.h" 1
 
 
 
 
 
 
 


	   
	 
	
int rsin_sub(int angle);
int rsin (int angle);
int rcos (int angle);
double quickSin (int angle);
double quickCos (int angle);


	 
extern short SinCosTable[];
# 23 "tuto7.c" 2

# 1 "atan.h" 1





int ratan (int x, int y);
int SUBratan (int x, int z);
int ratan_zero (int x, int z);


extern int ArcTangentTable[256];


# 24 "tuto7.c" 2

# 1 "pad.h" 1
 






























void	PadInit( long mode );
long	PadRead( int id );
void	PadStop( void );
long	PadRead2( short port );
# 25 "tuto7.c" 2

# 1 "tmd.h" 1
 















	 





	 
	 
void LinkObjectHandlerToTmdObject (GsDOBJ2 *objectHandler, 
					int whichObjectInTmdFile, u_long tmdAddress);

  	 
	 
	 
	 
void LinkArrayOfTmdsToObjectHandlerArray (int numberOfObjects,
		GsDOBJ2* handlerArray, u_long* addressesArray);


	 
int CountNumberOfObjectsInTmdFile (u_long tmdAddress);
# 26 "tuto7.c" 2

# 1 "asssert.h" 1
 













 



























































	








# 27 "tuto7.c" 2

# 1 "object.h" 1
 













# 1 "tmd.h" 1
 















	 





	 
	 
void LinkObjectHandlerToTmdObject (GsDOBJ2 *objectHandler, 
					int whichObjectInTmdFile, u_long tmdAddress);

  	 
	 
	 
	 
void LinkArrayOfTmdsToObjectHandlerArray (int numberOfObjects,
		GsDOBJ2* handlerArray, u_long* addressesArray);


	 
int CountNumberOfObjectsInTmdFile (u_long tmdAddress);
# 15 "object.h" 2

# 1 "asssert.h" 1
 













 



























































	








# 16 "object.h" 2



	
	



	





	 










typedef struct
{
	int id;
	int alive;		  
	int type;		 
	int which;	
		
	GsDOBJ2	handler;
	u_long modelAddress;
	int whichModel;

	int scalingFlag;
	VECTOR scalingVector;			 

	int movementTypeFlag;		 

	VECTOR position;		 
	VECTOR velocity;		
	int movementMomentumFlag;
	int movementSpeed;

	SVECTOR rotate;			 
	VECTOR twist;			 
	int rotationMomentumFlag;
	int rotationSpeed;

	GsCOORDINATE2 coord;	  
	int superCoordinateObjectID;
	MATRIX matrix;			 

	int inOrbit;		 
	int centralBodyID;		 
	int angle;		    
	int angleIncrement;	   
	int whichWay;		   
	int radius;			   
	VECTOR firstVector;		   
	VECTOR secondVector;	   

	int specialMovement;		 
	
	int lifeTime;
	int specialTimeLimit;
	
	int initialHealth;
	int currentHealth;
	
	int strategyFlag;
	int currentActionFlag;
	int numberFramesOfThisAction;
	
	int meritRating;
	
	int allegiance;	
	
	int firingRate;
	int framesSinceLastFire;	
} ObjectHandler;



extern ObjectHandler* ObjectArray[128 ];




		 



 

void InitialiseObjectClass (void);
int FindNextLowestObjectID (int objectID);
int FindNextHighestObjectID (int objectID);
int FindNextUnusedObjectID (void);
int CountNumberOfLivingObjects (void);
void LinkAllObjectsToModels (void);
void LinkAllObjectsToTheirCoordinateSystems (void);

 
		
void BringObjectToLife (ObjectHandler* object, int type,
		u_long modelAddress, int whichModel, 
			int superCoordinateObjectID);
void KillAnObject (ObjectHandler* object);
void RegisterObjectIntoObjectArray (ObjectHandler* object);
void RemoveObjectFromObjectArray (ObjectHandler* object);
void InitSingleObject (ObjectHandler* object);
void HighlightObject (ObjectHandler* object);
void UnHighlightObject (ObjectHandler* object);
void SetObjectScaling (ObjectHandler* object, int scaleX,
						int scaleY, int scaleZ);
void SortObjectSize (ObjectHandler* object);


# 28 "tuto7.c" 2

# 1 "dump.h" 1
 







































# 49 "dump.h"








			
			
			
			


















			






































	  


# 131 "dump.h"

	 















# 159 "dump.h"





 

 

 


# 29 "tuto7.c" 2







typedef struct 
{
	int x, y, z;
	int w, h, d;    
} CUBOID;




































static GsOT	Sot[2];			 
static GsOT_TAG	stags[2][16];		
static GsOT Wot[2];			 
static GsOT_TAG wtags[2][1<< 9 ]; 
static GsDOBJ2	Models[1200 ]; 	 
static GsCOORDINATE2 DWorld[1200 ];




	 
static SVECTOR	PVect;	


		
static GsRVIEW2 view;	

int ViewAdjustment = 20;		


static GsF_LIGHT TheLights[3];		


int ReferenceDistance, ViewpointZDistance, ViewpointYDistance;

static PACKET packetArea[2][(2048 *24) ];  

static int nModels;

long* dop1;
long* dop2;
long* dop3;
long* dop4;
long* dop5;
long* dop6;



GsFOGPARAM fogparam;

GsLINE line;

GsLINE ArrowLines[3];

GsBOXF box[2];

short lightmode;













static char worldmaps[40 ][40 ][40 ];
static GsCOORDINATE2 World[40 ][40 ][40 ];







int MainMode;









int frameNumber = 0;
int QuitFrameNumber = -1;




 





ObjectHandler PlayersShip;


ObjectHandler TheBullets[50 ];



ObjectHandler TheShips[20 ];



ObjectHandler TheCubes[20 ];


   
int PlayerBulletSpeedFactor;
int EnemyBulletSpeedFactor;			  

	 



	 







  


	 











	


	 



char TextStrings[20 ][50 ];	


int LevelNumber = 1;

int NumberEnemiesLeft = 20 ;

















int CompassDirectionToNearestEnemy = 1001 ;
int ExactDirectionToNearestEnemy = 8192;











 




void main (void);

void CheckForEndOfLevel (void);
int CountNumberOfEnemiesLeft (void);

void draw_world_maps (GsOT* ot);

void NewDrawWorldMaps( GsOT* ot );


void DealWithControllerPad(void);
void PlayerFiresAShot (void);
void EnemyShipFiresAShot (ObjectHandler* enemy);

void move_lighting_spot(void);
void NewMoveLightingSpot (void);


void InitialiseAll(void);
void InitialiseObjects (void);
void InitialiseShipAccordingToStrategy (ObjectHandler* object);

void HandleAllObjects (void);

void UpdateObjectCoordinates (VECTOR* twist,
							VECTOR* position, VECTOR* velocity,
							GsCOORDINATE2* coordSystem, MATRIX* matrix);
void UpdateObjectCoordinates2 (SVECTOR* rotationVector,
							VECTOR* translationVector,
							GsCOORDINATE2* coordSystem);
void UpdateObjectCoordinates3 (SVECTOR* rotation, VECTOR* twist,
							VECTOR* position, VECTOR* velocity,
							GsCOORDINATE2* coordSystem);


int CollisionWithWalls (VECTOR* position, VECTOR* movement);	

int NotSafe (CUBOID* rectangle);




void InitialiseView(void);
void InitialiseLighting(void);




int InitialiseTexture(long addr);
long* InitialiseModel(long* adrs);
void make_world_maps(void);



int calc_world_data(void);
int NewCalculateWorldData (void);
int MinOfFour (int a, int b, int c, int d);
int MaxOfFour (int a, int b, int c, int d);




int calc_model_data(int n, int px, int py, int fact, int atrb);
void draw_world_maps( GsOT* ot );
int collision( int x, int y );


void PrintObject (ObjectHandler* object);

void PositionSomewhereNotInAWall (ObjectHandler* object);


void HandleEnemyBehaviour (ObjectHandler* object);

void HandleWaitingShipsBehaviour (ObjectHandler* object);
void HandleStationaryTrackingShipsBehaviour (ObjectHandler* object);
void HandleSeekingShipBehaviour (ObjectHandler* object);
void HandleRandomShipsBehaviour (ObjectHandler* object);




void HandlePlayersDeath (void);
void HandleEnemysDeath (ObjectHandler* object);

int CheckCollisions (void); 

int ObjectsVeryClose (ObjectHandler* first, ObjectHandler* second);

void ExplodeObject (ObjectHandler* object);

void DummyGuiLoopForTextPrinting (int numberOfStrings, int quitKey);

void ResetAll (void);

void HandleLevelTransition (void);

int FindDirectionToNearestLivingEnemy (int* exactDirection);
void PrintCompassDirectionToNearestEnemy (int direction);






 




















 








void main( void )
{
	int	i;
	int	hsync = 0;
	GsDOBJ2 *op;
	int side;			   
	MATRIX	tmpls, tmplw;
	ObjectHandler** pointer;
	ObjectHandler* object;
	int x, y;
	int viewX, viewY;



	InitialiseAll();

   

	side = GsGetActiveBuff();

	while(1)
		{
		if (QuitFrameNumber == frameNumber)
			break;

		if (frameNumber % 100 == 0)
			CheckForEndOfLevel();

		 
		 
		 
		FntPrint("frame: %d\n", frameNumber);
		FntPrint("player health: %d\n", PlayersShip.currentHealth);	 
		FntPrint("player score: %d\n", PlayersShip.meritRating);
		FntPrint("level: %d\n", LevelNumber);

		 
		 

			 
		if (frameNumber % 10 == 0 && frameNumber > 5)
			{
			CompassDirectionToNearestEnemy 
				= FindDirectionToNearestLivingEnemy(&ExactDirectionToNearestEnemy);
			}


		FntPrint("enemies left: %d\n", NumberEnemiesLeft);
		if (frameNumber % 20 == 0)
			{
			NumberEnemiesLeft = CountNumberOfEnemiesLeft();
			}

				
		
# 466 "tuto7.c"


		FntPrint("ship pos: \n%d %d %d\n", 
			PlayersShip.position.vx, 
			PlayersShip.position.vy,
			PlayersShip.position.vz); 
		x = PlayersShip.position.vx / 128 ;
		y = PlayersShip.position.vz / 128 ;
		FntPrint("ship grid: %d %d\n", x, y);
		viewX = PlayersShip.position.vx + ((ViewpointZDistance * rsin(PlayersShip.rotate.vy)) >> 12);
		viewY = PlayersShip.position.vz + ((ViewpointZDistance * rcos(PlayersShip.rotate.vy)) >> 12);
		FntPrint("view: %d %d\n", viewX, viewY);

		frameNumber++;

		DealWithControllerPad();

		if (view.super == 0  )
			move_lighting_spot();
		else
			NewMoveLightingSpot();


		if (view.super == 0  )
			nModels = calc_world_data();
		else if (view.super == &PlayersShip.coord)
			nModels = NewCalculateWorldData();


# 505 "tuto7.c"

			

		GsSetRefView2(&view);

		GsSetWorkBase((PACKET*)packetArea[side]);

		GsClearOt(0,0,&Wot[side]);
		GsClearOt(0,0,&Sot[side]);


		op = Models;
		for( i=0; i<nModels; i++ ) 
			{
			GsGetLws(op->coord2,&tmplw, &tmpls);	
			GsSetLightMatrix(&tmplw);	
			GsSetLsMatrix(&tmpls);	   
			GsSortObject4(op,&Wot[side],3,((u_long *)(0x1f800000+ 0 *4)) );
			op++;
			}


		HandleAllObjects();

		pointer = &(ObjectArray[0]);
		for (i = 0; i < 128 ; i++) 
			{
			if (*pointer != 0 )
				{
				if ( (*pointer)->alive == 1 )
					{
					object = *pointer;

					GsGetLs(&(object->coord), &tmpls);
			   
					GsSetLightMatrix(&tmpls);
				
					GsSetLsMatrix(&tmpls);
				
					GsSortObject4( &(object->handler), 
						&Wot[side], 
							3, ((u_long *)(0x1f800000+ 0 *4)) );
					}	 
				}
			pointer++;
			}

		 
		NewDrawWorldMaps(&Sot[side]);
		hsync = VSync(2);
		ResetGraph(1);
		GsSwapDispBuff();
		GsSortClear(0,0,4,&Wot[side]);
		GsDrawOt(&Wot[side]);
		GsDrawOt(&Sot[side]);
		side ^= 1;
		FntFlush(-1);
		}

	ResetGraph(3);
}




void CheckForEndOfLevel (void)
{
	int i;
	int boolean = 1 ;

	for (i = 0; i < 20 ; i++)
		{
		if (TheShips[i].alive == 1 )
			{
			boolean = 0 ;
			break;
			}
		}
	
	if (boolean == 1 )
		HandleLevelTransition();
}




int CountNumberOfEnemiesLeft (void)
{
	int count = 0;
	int i;

	for (i = 0; i < 20 ; i++)
		{
		if (TheShips[i].alive == 1 )
			{
			count++;
			}
		}

	return count;
}







	 
void draw_world_maps( GsOT* ot )
{

	line.attribute = 0;
	line.r = line.g = line.b = 128;
	line.x0 = 320 /2-48; line.y0 = - 240 /2+48;
	line.x1 = line.x0 + (rsin( PVect.vy )/256);
	line.y1 = line.y0 - (rcos( PVect.vy )/256);

	(  &box[0] )->x = (  line.x0-16 ),(  &box[0] )->y = (  line.y0-16 ),(  &box[0] )->w = (  32 ),(  &box[0] )->h = (  32  ) ;
	box[0].x += ( rsin( PVect.vy )/256 );
	box[0].y -= ( rcos( PVect.vy )/256 );
	box[0].r = 0; box[0].g = 0; box[0].b = 128;

	box[1].attribute = 1<<30;	   
	(  &box[1] )->x = (  line.x0-32 ),(  &box[1] )->y = (  line.y0-32 ),(  &box[1] )->w = (  64 ),(  &box[1] )->h = (  64  ) ;
	box[1].r = 128; box[1].g = 128; box[1].b = 128;

	GsSortLine( &line, ot, 2 );
	GsSortBoxFill( &box[0], ot, 2 );
	GsSortBoxFill( &box[1], ot, 2 );
}







VECTOR shipDirection;
VECTOR nearestEnemyDirection;
VECTOR goingEast, goingWest;

	 
void NewDrawWorldMaps( GsOT* ot )
{
	shipDirection.vx = rsin(PlayersShip.rotate.vy);
	shipDirection.vy = 0;
	shipDirection.vz = -rcos(PlayersShip.rotate.vy);

	nearestEnemyDirection.vx = rsin(ExactDirectionToNearestEnemy);
	nearestEnemyDirection.vy = 0;
	nearestEnemyDirection.vz = -rcos(ExactDirectionToNearestEnemy);

	goingEast.vx = nearestEnemyDirection.vz;
	goingEast.vy = 0;
	goingEast.vz = -nearestEnemyDirection.vx;

	goingWest.vx = -nearestEnemyDirection.vz;
	goingWest.vy = 0;
	goingWest.vz = nearestEnemyDirection.vx;
	
	line.attribute = 0;
	line.r = line.g = line.b = 128;

	line.x0 = 320 /2-48; line.y0 = - 240 /2+48;

	line.x1 = line.x0 + ((30 * shipDirection.vx)>>12);
	line.y1 = line.y0 + ((30 * shipDirection.vz)>>12);



	box[1].attribute = 1<<30;	   
	(  &box[1] )->x = (  line.x0-30 ),(  &box[1] )->y = (  line.y0-29 ),(  &box[1] )->w = (  64 ),(  &box[1] )->h = (  64  ) ;
	box[1].r = 128; box[1].g = 128; box[1].b = 128;


	
	ArrowLines[0].r = 255; ArrowLines[0].g = 128; ArrowLines[0].b = 128;
	ArrowLines[0].attribute = 0;
	ArrowLines[0].x0 = 112; ArrowLines[0].y0 = -72;
	ArrowLines[0].x1 = ArrowLines[0].x0 + ((25 * nearestEnemyDirection.vx)>>12);
	ArrowLines[0].y1 = ArrowLines[0].y0 + ((25 * nearestEnemyDirection.vz)>>12);

	ArrowLines[1].r = 255; ArrowLines[1].g = 128; ArrowLines[1].b = 128;
	ArrowLines[1].attribute = 0;
	ArrowLines[1].x0 = ArrowLines[0].x1; ArrowLines[1].y0 = ArrowLines[0].y1;
	ArrowLines[1].x1 = ArrowLines[1].x0 - ((10 * nearestEnemyDirection.vx)>>12) + ((10 * goingWest.vx)>>12);
	ArrowLines[1].y1 = ArrowLines[1].y0 - ((10 * nearestEnemyDirection.vz)>>12) + ((10 * goingWest.vz)>>12);

	ArrowLines[2].r = 255; ArrowLines[2].g = 128; ArrowLines[2].b = 128;
	ArrowLines[2].attribute = 0;
	ArrowLines[2].x0 = ArrowLines[0].x1; ArrowLines[2].y0 = ArrowLines[0].y1;
	ArrowLines[2].x1 = ArrowLines[2].x0 - ((10 * nearestEnemyDirection.vx)>>12) + ((10 * goingEast.vx)>>12);
	ArrowLines[2].y1 = ArrowLines[2].y0 - ((10 * nearestEnemyDirection.vz)>>12) + ((10 * goingEast.vz)>>12);


	GsSortLine( &line, ot, 2 );
	GsSortLine( &ArrowLines[0], ot, 2 );
	GsSortLine( &ArrowLines[1], ot, 2 );
	GsSortLine( &ArrowLines[2], ot, 2 );
	 
	GsSortBoxFill( &box[1], ot, 2 );
	

# 728 "tuto7.c"

}









void DealWithControllerPad (void)
{
	int	spd;
	long	pad;
	long	range;
	short	vx, vz;	    
	static int framesSinceLastModeToggle = 0;
  
	pad = PadRead(0);

	 
		 
	
		 
	switch(MainMode)
		{
		case 0 :
			{
			spd = 2 ;
			if( pad & (1<< 5)  ) spd = spd*4;

				 
			if(pad & (1<<15) ) {
				PVect.vy = (PVect.vy-spd*8)&4095;
			}

			if(pad & (1<<13) ) {
				PVect.vy = (PVect.vy+spd*8)&4095;
			}

				 
			if((pad & (1<< 1) )&&(PVect.vx+spd*8<960)) {
				PVect.vx = (PVect.vx+spd*8);
			}
			if((pad & (1<< 0) )&&(PVect.vx-spd*8>-960)) {
				PVect.vx = (PVect.vx-spd*8);
			}

			vz = vx = 0;
			if(pad & (1<<12) ) {
				vz += (rcos( PVect.vy )/64*spd)/16;
				vx += (rsin( PVect.vy )/64*spd)/16;
			}
			if(pad & (1<<14) ) {
				vz -= (rcos( PVect.vy )/64*spd)/16;
				vx -= (rsin( PVect.vy )/64*spd)/16;
			}
				 
			if(pad & (1<< 3) ) {
				vz += (rcos((PVect.vy+1024)&4095)/64*spd)/16;
				vx += (rsin((PVect.vy+1024)&4095)/64*spd)/16;
			}
			if(pad & (1<< 2) ) {
				vz += (rcos((PVect.vy-1024)&4095)/64*spd)/16;
				vx += (rsin((PVect.vy-1024)&4095)/64*spd)/16;
			}

				 
			if( vz>0 ) {
				if(collision(    0, vz+ 112 )) vz = 0;
				if(collision(- 112 , vz+ 112 )) vz = 0;
				if(collision( 112 , vz+ 112 )) vz = 0;
			}
			if( vz<0 ) {
				if(collision(    0, vz- 112 )) vz = 0;
				if(collision(- 112 , vz- 112 )) vz = 0;
				if(collision( 112 , vz- 112 )) vz = 0;
			}
			if( vx>0 ) {
				if(collision( vx+ 112 ,     0)) vx = 0;
				if(collision( vx+ 112 ,  112 )) vx = 0;
				if(collision( vx+ 112 , - 112 )) vx = 0;
			}
			if( vx<0 ) {
				if(collision( vx- 112 ,     0)) vx = 0;
				if(collision( vx- 112 ,  112 )) vx = 0;
				if(collision( vx- 112 , - 112 )) vx = 0;
			}

			if( vz || vx ) {
				view.vpz += vz;
				view.vpx += vx;
			}

			range = rcos( PVect.vx );
			view.vrz = (view.vpz+rcos( PVect.vy )*range/ 4096 );
			view.vrx = (view.vpx+rsin( PVect.vy )*range/ 4096 );
			view.vry = rsin( PVect.vx ) + 28 ;
			}
			break;
		case 1 :
				 
			if (pad & (1<<12) )
				PlayersShip.velocity.vz -= PlayersShip.movementSpeed;
			if (pad & (1<<14) )
				PlayersShip.velocity.vz += PlayersShip.movementSpeed;

				 
			if (pad & (1<< 0)  )
				{
				if (PlayersShip.framesSinceLastFire > PlayersShip.firingRate)
					{
					PlayerFiresAShot();
					PlayersShip.framesSinceLastFire = 0;
					}
				}
			PlayersShip.framesSinceLastFire++;

				 
			if (pad & (1<< 5) )
				PlayersShip.twist.vy += PlayersShip.rotationSpeed;
			if (pad & (1<< 7) )
				PlayersShip.twist.vy -= PlayersShip.rotationSpeed;
			break;
		case 2 :
			if (pad & (1<< 4) )
				{
				ReferenceDistance += 5;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			if (pad & (1<< 6) )
				{
				ReferenceDistance -= 5;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			if (pad & (1<<12) )
				{
				ViewpointYDistance += 5;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			if (pad & (1<<14) )
				{
				ViewpointYDistance -= 5;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			if (pad & (1<< 7) )
				{
				ViewpointZDistance -= 20;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			if (pad & (1<< 5) )
				{
				ViewpointZDistance += 20;
				view.vrx = 0; view.vry = 0; view.vrz = ReferenceDistance;
				view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
				GsSetRefView2(&view);
				}
			break;
		default:
			( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	898, "tuto7.c"), exit(1), 0) ) ;
		}

# 924 "tuto7.c"



		 
	if (pad & (1<< 8)   && pad & (1<< 1)  )
		{
		int frameCount;	 
		frameCount = VSync(-1);
		while (frameCount + 25 > VSync(-1))
			{
			;
			}
		}

		 
	if (pad & (1<<11)   && pad & (1<< 8)  )
		{
		QuitFrameNumber = frameNumber + 1;
		}


		 
	if (pad & (1<<11)  )
		{
		while (pad & (1<<11)  )
			{
			pad = PadRead(0);
			}
		}
}





void PlayerFiresAShot (void)
{
	int bulletID = -1;
	int i;	

		 
	for (i = 0; i < 50 ; i++)
		{
		if (TheBullets[i].alive == 0 )
			{
			bulletID = i;
			break;
			}
		}

	if (bulletID == -1)		 
		return;
	else
		{
		TheBullets[bulletID].alive = 1 ;
		TheBullets[bulletID].lifeTime = 0;
		TheBullets[bulletID].allegiance = 0 ;

			 
		TheBullets[bulletID].rotationMomentumFlag = 1 ;
		TheBullets[bulletID].twist.vx = rand() % 20;
		TheBullets[bulletID].twist.vy = rand() % 20;
			 
			 
		TheBullets[bulletID].movementMomentumFlag = 1 ;
		TheBullets[bulletID].velocity.vx = PlayersShip.coord.coord.m[2][0] >> PlayerBulletSpeedFactor;
		TheBullets[bulletID].velocity.vy = PlayersShip.coord.coord.m[2][1] >> PlayerBulletSpeedFactor;
		TheBullets[bulletID].velocity.vz = -PlayersShip.coord.coord.m[2][2] >> PlayerBulletSpeedFactor; 
		
					 
		TheBullets[bulletID].position.vx = PlayersShip.position.vx;
		TheBullets[bulletID].position.vy = PlayersShip.position.vy;
		TheBullets[bulletID].position.vz = PlayersShip.position.vz;
		}
}






void EnemyShipFiresAShot (ObjectHandler* enemy)
{
	int bulletID = -1;
	int i;	

		 
	for (i = 0; i < 50 ; i++)
		{
		if (TheBullets[i].alive == 0 )
			{
			bulletID = i;
			break;
			}
		}

	if (bulletID == -1)		 
		return;
	else
		{
		TheBullets[bulletID].alive = 1 ;
		TheBullets[bulletID].lifeTime = 0;
		TheBullets[bulletID].allegiance = 2 ;

			 
		TheBullets[bulletID].rotationMomentumFlag = 1 ;
		TheBullets[bulletID].twist.vx = rand() % 20;
		TheBullets[bulletID].twist.vy = rand() % 20;
			 
			 
		TheBullets[bulletID].movementMomentumFlag = 1 ;
		TheBullets[bulletID].velocity.vx = enemy->coord.coord.m[2][0] >> EnemyBulletSpeedFactor;
		TheBullets[bulletID].velocity.vy = enemy->coord.coord.m[2][1] >> EnemyBulletSpeedFactor;
		TheBullets[bulletID].velocity.vz = -enemy->coord.coord.m[2][2] >> EnemyBulletSpeedFactor; 
		
					 
		TheBullets[bulletID].position.vx = enemy->position.vx;
		TheBullets[bulletID].position.vy = enemy->position.vy;
		TheBullets[bulletID].position.vz = enemy->position.vz;
		}
}





 
int collision (int vx, int vz )
{
	int	wx, wz;

	wx = ((view.vpx+ 128 /2)+vx);
	wz = ((view.vpz+ 128 /2)+vz);
	if( wx<0 || wz<0 ) return(1);

	wx = wx/ 128 ; wz = wz/ 128 ;
	if( wx>= 40  || wz<0 || wz>= 40  ) return(1);

	return( worldmaps[wx][wz] );
}




 
void move_lighting_spot( void )
{
	TheLights[0].r = TheLights[0].g = TheLights[0].b = 0x70;
	TheLights[0].vx = view.vrx - view.vpx;
	TheLights[0].vy = 4096;			  
	TheLights[0].vz = view.vrz - view.vpz;
	GsSetFlatLight(0,&TheLights[0]);

	TheLights[1].r = TheLights[1].g = TheLights[1].b = 0x70;
	TheLights[1].vx = view.vrx - view.vpx;
	TheLights[1].vy = -4096;			  
	TheLights[1].vz = view.vrz - view.vpz;
	GsSetFlatLight(1,&TheLights[1]);
}


   
void NewMoveLightingSpot (void)
{
	TheLights[0].r = TheLights[0].g = TheLights[0].b = 0x70;
	TheLights[0].vx = PlayersShip.coord.coord.t[0];
	TheLights[0].vy = 4096;			  
	TheLights[0].vz = PlayersShip.coord.coord.t[2];
	GsSetFlatLight(0,&TheLights[0]);

	TheLights[1].r = TheLights[1].g = TheLights[1].b = 0x70;
	TheLights[1].vx = PlayersShip.coord.coord.t[0];
	TheLights[1].vy = -4096;			  
	TheLights[1].vz = PlayersShip.coord.coord.t[2];
	GsSetFlatLight(1,&TheLights[1]);
}




 
int calc_world_data (void)
{
	int	n;
	int	x, y;
	int	px, py;
	int	sx, sy, ex, ey;
	int	fact;

	fact = 128 ;

	px = (view.vpx+fact/2)/fact;		 
	py = (view.vpz+fact/2)/fact;


	sx = px - 4; ex = px + 4;		    
	sy = py - 4; ey = py + 4;

	sx += ( rsin( PVect.vy )/1000 );
	sy += ( rcos( PVect.vy )/1000 );
	ex += ( rsin( PVect.vy )/1000 );
	ey += ( rcos( PVect.vy )/1000 );

	if( sx<0 ) sx = 0;
	if( sy<0 ) sy = 0;
	if( ex>= 40  ) ex = 40 -1;
	if( ey>= 40  ) ey = 40 -1;






	n = 0;				   
	for( x=sx; x<=ex; x++ ) {
		for( y=sy; y<=ey; y++ ) {
			if( abs(px-x)<3 && abs(py-y)<3 ) {
				 
				n = calc_model_data( n, x, y, fact, (1<<9)  );
			} else	{
				n = calc_model_data( n, x, y, fact, 0 );
			}
		}
	}
	return( n );
}





VECTOR p1, p2, p3, p4;
VECTOR radius, easternTgt, westernTgt;	  

 
 


int NewCalculateWorldData (void)
{	
	int numberOfModels;
	int	x, y;
	int px, py;
	int	sx, sy, ex, ey;		   
	int	fact;				   
	static int ClipDistance = 4 * 128 ;	
	int viewX, viewY;

	fact = 128 ;

	 
	 

	radius.vx = rsin(PlayersShip.rotate.vy);
	radius.vy = 28 ;
	radius.vz = rcos(PlayersShip.rotate.vy);

	easternTgt.vx = radius.vz;
	easternTgt.vy = 28 ;
	easternTgt.vz = -radius.vx;

	westernTgt.vx = -radius.vz;
	westernTgt.vy = 28 ;
	westernTgt.vz = radius.vx;

	viewX = PlayersShip.position.vx + ((ViewpointZDistance * rsin(PlayersShip.rotate.vy)) >> 12);
	viewY = PlayersShip.position.vz + ((ViewpointZDistance * rcos(PlayersShip.rotate.vy)) >> 12);
		

		
	p1.vx = viewX + ((-(radius.vx*2) + westernTgt.vx) * ClipDistance >> 12);
	p1.vy = PlayersShip.position.vy;
	p1.vz = viewY + ((-(radius.vz*2) + westernTgt.vz) * ClipDistance >> 12);
	p2.vx = viewX + ((-(radius.vx*2) + easternTgt.vx) * ClipDistance >> 12);   
	p2.vy = PlayersShip.position.vy;
	p2.vz = viewY + ((-(radius.vz*2) + easternTgt.vz) * ClipDistance >> 12);
	p3.vx = viewX + ((radius.vx/2 + westernTgt.vx) * ClipDistance >> 12);
	p3.vy = PlayersShip.position.vy;
	p3.vz = viewY + ((radius.vz/2 + westernTgt.vz) * ClipDistance >> 12);
	p4.vx = viewX + ((radius.vx/2 + easternTgt.vx) * ClipDistance >> 12);
	p4.vy = PlayersShip.position.vy;
	p4.vz = viewY + ((radius.vz/2 + easternTgt.vz) * ClipDistance >> 12);	

	

	sx = MinOfFour(p1.vx, p2.vx, p3.vx, p4.vx)/fact;
	sy = MinOfFour(p1.vz, p2.vz, p3.vz, p4.vz)/fact;
	ex = MaxOfFour(p1.vx, p2.vx, p3.vx, p4.vx)/fact;
	ey = MaxOfFour(p1.vz, p2.vz, p3.vz, p4.vz)/fact;
   
	if( sx<0 ) sx = 0;
	if( sy<0 ) sy = 0;
	if( ex>= 40  ) ex = 40 -1;
	if( ey>= 40  ) ey = 40 -1;

# 1234 "tuto7.c"


	px = (sx + ex) / 2;
	py = (sy + ey) / 2;

	 

	numberOfModels = 0;				   
	for (x = sx; x <= ex; x++) 
		{
		for (y = sy; y <= ey; y++) 
			{
			if( abs(px-x)<4 && abs(py-y)<4 ) 
				{
				numberOfModels = calc_model_data( numberOfModels, x, y, fact, (1<<9)  );
				} 
			else	
				{
				numberOfModels = calc_model_data( numberOfModels, x, y, fact, 0 );
				}

			if (numberOfModels > 1200 )
				{
				numberOfModels = 1200 ;
				printf("Forcibly holding number of models at OBJMAX %d\n", 1200 );
				goto end;
				}
			}
		}


end:

	 

	return(numberOfModels);
}





int MinOfFour (int a, int b, int c, int d)
{
	int result, t1, t2;

	t1 = ( (( a ) > ( b )) ? ( b ) : ( a )) ; t2 = ( (( c ) > ( d )) ? ( d ) : ( c )) ;
	result = ( (( t1 ) > (  t2 )) ? (  t2 ) : ( t1 )) ;

	return result;
}


int MaxOfFour (int a, int b, int c, int d)
{
	int result, t1, t2;

	t1 = ( (( a ) > ( b )) ? ( a ) : ( b )) ; t2 = ( (( c ) > ( d )) ? ( c ) : ( d )) ;
	result = ( (( t1 ) > (  t2 )) ? ( t1 ) : (  t2 )) ;

	return result;
}




	 
int calc_model_data (int n, int px, int py, int fact, int atrb )
{
	if( worldmaps[px][py]& 0x01  ) return(n);

	if(( worldmaps[px-1][py]& 0x01 )|| px==0 ) {	   
		GsInitCoordinate2( &World[px][py], &DWorld[n] );
		DWorld[n].coord.t[0] = 0;
		DWorld[n].coord.t[1] = 0;
		DWorld[n].coord.t[2] = 0;
		GsLinkObject4((long)dop4, &Models[n],0);
		Models[n].coord2 = &DWorld[n];
		Models[n].attribute = atrb;
		n++;
	}

	if(( worldmaps[px+1][py]& 0x01 )|| px== 40 -1 ) {	    
		GsInitCoordinate2( &World[px][py], &DWorld[n] );
		DWorld[n].coord.t[0] = 0;
		DWorld[n].coord.t[1] = 0;
		DWorld[n].coord.t[2] = 0;
		GsLinkObject4((long)dop3, &Models[n],0);
		Models[n].coord2 = &DWorld[n];
		Models[n].attribute = atrb;
		n++;
	}

	if(( worldmaps[px][py-1]& 0x01 ) || py==0 ) {			  
		GsInitCoordinate2( &World[px][py], &DWorld[n] );
		DWorld[n].coord.t[0] = 0;
		DWorld[n].coord.t[1] = 0;
		DWorld[n].coord.t[2] = 0;
		GsLinkObject4((long)dop1, &Models[n],0);
		Models[n].coord2 = &DWorld[n];
		Models[n].attribute = atrb;
		n++;
	}

	if(( worldmaps[px][py+1]& 0x01 ) || py== 40 -1 ) {	  
		GsInitCoordinate2( &World[px][py], &DWorld[n] );
		DWorld[n].coord.t[0] = 0;
		DWorld[n].coord.t[1] = 0;
		DWorld[n].coord.t[2] = 0;
		GsLinkObject4((long)dop2, &Models[n],0);
		Models[n].coord2 = &DWorld[n];
		Models[n].attribute = atrb;
		n++;
	}

	GsInitCoordinate2(&World[px][py], &DWorld[n] );				 
	DWorld[n].coord.t[0] = 0;
	DWorld[n].coord.t[1] = - ( fact );
	DWorld[n].coord.t[2] = 0;
	GsLinkObject4((long)dop5, &Models[n],0);
	Models[n].coord2 = &DWorld[n];
	Models[n].attribute = atrb;
	n++;

	GsInitCoordinate2(&World[px][py], &DWorld[n] );				 
	DWorld[n].coord.t[0] = 0;
	DWorld[n].coord.t[1] = fact;
	DWorld[n].coord.t[2] = 0;
	GsLinkObject4((long)dop6, &Models[n],0);
	Models[n].coord2 = &DWorld[n];
	Models[n].attribute = atrb;
	n++;

	return( n );
}







void InitialiseAll (void)
{
	PadInit(0);


	GsInitGraph(320 ,240 ,1 | 4 ,1,0);
	if( 240 <480 )
		GsDefDispBuff(0,0,0,240 );
	else
		GsDefDispBuff(0,0,0,0);

	GsInit3D();		   

	Wot[0].length= 9 ;	
	Wot[0].org=wtags[0];	   
	Wot[1].length= 9 ;
	Wot[1].org=wtags[1];

	Sot[0].length=4;
	Sot[0].org=stags[0];
	Sot[1].length=4;
	Sot[1].org=stags[1];

	GsClearOt(0,0,&Wot[0]);
	GsClearOt(0,0,&Wot[1]);
	GsClearOt(0,0,&Sot[0]);
	GsClearOt(0,0,&Sot[1]);

	InitialiseView();			
	InitialiseLighting();		   

	InitialiseTexture(0x800a0000 );

		
	dop1 = InitialiseModel((long*)0x80090000 );	
	dop2 = InitialiseModel((long*)0x80091000 );	
	dop3 = InitialiseModel((long*)0x80092000 );	
	dop4 = InitialiseModel((long*)0x80093000 );	
	dop5 = InitialiseModel((long*)0x80094000 ); 
	dop6 = InitialiseModel((long*)0x80095000 );	

	make_world_maps();
	nModels = calc_world_data();

	InitialiseObjects();

	 
	MainMode = 1 ;

	FntLoad( 960, 256);
	FntOpen( 0, 0, 256, 200, 0, 512);		   

	 

	PlayerBulletSpeedFactor = 7;
	EnemyBulletSpeedFactor = 8;
}





void InitialiseObjects (void)
{
	int i;

	InitialiseObjectClass();
	printf("1\n");

	InitSingleObject(&PlayersShip);

	BringObjectToLife (&PlayersShip, 0 , 
					0x80096000 , 0, 1001 );
	RegisterObjectIntoObjectArray(&PlayersShip);

	PositionSomewhereNotInAWall(&PlayersShip);
	PlayersShip.initialHealth = 1000;
	PlayersShip.currentHealth = 1000;
	PlayersShip.allegiance = 0 ;
	PlayersShip.position.vy += 20;

	PlayersShip.movementSpeed = 48;
	PlayersShip.rotationSpeed = 45;
	PlayersShip.firingRate = 3;
	PlayersShip.framesSinceLastFire = 0;

	
	printf("2\n");
		

	for (i = 0; i < 50 ; i++)
		{
		InitSingleObject(&TheBullets[i]);

		BringObjectToLife(&TheBullets[i], 1 , 
			0x80097000 , 0, 1001 );

		SetObjectScaling(&TheBullets[i], 4096 >>5, 4096 >>5, 4096 >>5);
		TheBullets[i].position.vy += 20;

		RegisterObjectIntoObjectArray(&TheBullets[i]);
		}
	printf("3\n");


	for (i = 0; i < 20 ; i++)
		{
		InitSingleObject(&TheCubes[i]);

		BringObjectToLife(&TheCubes[i], 3 , 
			0x80097000 , 0, 1001 );

		SetObjectScaling(&TheCubes[i], 4096 >>3, 4096 >>3, 4096 >>3);
		TheCubes[i].position.vy += 20;

		RegisterObjectIntoObjectArray(&TheCubes[i]);
		}
	printf("4\n");




	for (i = 0; i < 20 ; i++)
		{
		InitSingleObject(&TheShips[i]);

		BringObjectToLife(&TheShips[i], 2 , 
			0x80096000 , 0, 1001 );

		TheShips[i].initialHealth = 1;
		TheShips[i].currentHealth = 1;
			 
		TheShips[i].strategyFlag = rand() % (4 -1);
		InitialiseShipAccordingToStrategy(&TheShips[i]);

		PositionSomewhereNotInAWall(&TheShips[i]);
		TheShips[i].allegiance = 2 ;

		TheShips[i].position.vy += 20;

		RegisterObjectIntoObjectArray(&TheShips[i]);
		}
	printf("5\n");



	LinkAllObjectsToModels();
	printf("6\n");
	LinkAllObjectsToTheirCoordinateSystems();
	printf("7\n");



	for (i = 0; i < 50 ; i++)
		{
		TheBullets[i].alive = 0 ;		 
		}
	for (i = 0; i < 20 ; i++)
		{
		TheCubes[i].alive = 0 ;		 
		}
	printf("8\n");
}




void InitialiseShipAccordingToStrategy (ObjectHandler* object)
{
	object->movementSpeed = 32;
	object->rotationSpeed = 45;		

	switch(object->strategyFlag)
		{
		case 0 :	 
			object->specialTimeLimit = 400 + (100 * (rand() % 4));
			object->firingRate = 6;
			break;
		case 1 :
			object->firingRate = 5;	
			break;	
		case 2 :
			object->firingRate = 7;
			break;
		case 3 :
			object->specialTimeLimit = 10 + (rand() % 10);
			object->firingRate = 8 + (rand() % 6);
			break;
		default:
			( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	1565, "tuto7.c"), exit(1), 0) ) ;
		}
}




 



void HandleAllObjects (void)
{
	ObjectHandler* object;
	int gridX, gridY;
	int i;

	CheckCollisions();

	for (i = 0; i < 128 ; i++)
		{
		 
		if (ObjectArray[i] != 0 )
			{
			if (ObjectArray[i]->alive == 1 )
				{
				object = ObjectArray[i];
				object->lifeTime++;

				switch(object->type)
					{
					case 0 :
						 
						 

						object->rotate.vx += object->twist.vx;
						object->rotate.vy += object->twist.vy;
						object->rotate.vz += object->twist.vz;

							 
						UpdateObjectCoordinates3 (&object->rotate, &object->twist,
							&object->position, &object->velocity,
							&object->coord);

						SortObjectSize(object);

						{	if (( object->position.vx ) < (  0 ))	( object->position.vx ) = (  0 );	else if (( object->position.vx ) > (  40 * 128  ))	( object->position.vx ) = (  40 * 128  );	} ;
						{	if (( object->position.vz ) < (  0 ))	( object->position.vz ) = (  0 );	else if (( object->position.vz ) > (  40 * 128  ))	( object->position.vz ) = (  40 * 128  );	} ;

							 
						if (object->movementMomentumFlag == 0 )
							{
							object->velocity.vx = 0;
							object->velocity.vy = 0;
							object->velocity.vz = 0;
							}
						if (object->rotationMomentumFlag == 0 )
							{
							object->twist.vx = 0;
							object->twist.vy = 0;
							object->twist.vz = 0;
							}

						






						if (object->currentHealth < 1)
							{
							HandlePlayersDeath();
							goto endOfHandleAllObjects;
							}
						break;
					case 1 :
						UpdateObjectCoordinates2(&object->rotate,  
							&object->position, &object->coord);

						SortObjectSize(object);

							 
						object->rotate.vx += object->twist.vx;
						object->rotate.vy += object->twist.vy;
						object->rotate.vz += object->twist.vz;

							 
						object->position.vx += object->velocity.vx;
						object->position.vy += object->velocity.vy;
						object->position.vz += object->velocity.vz;

							 
						if (object->movementMomentumFlag == 0 )
							{
							object->velocity.vx = 0;
							object->velocity.vy = 0;
							object->velocity.vz = 0;
							}
						if (object->rotationMomentumFlag == 0 )
							{
							object->twist.vx = 0;
							object->twist.vy = 0;
							object->twist.vz = 0;
							}

							 
						gridX = object->position.vx / 128 ;
						gridY = object->position.vz / 128 ;

							 
						if (object->lifeTime > 50)
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}

						if (worldmaps[gridX][gridY] == 0x01 )
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}

						if (gridX < 0 || gridX >= 40 
							|| gridY < 0 || gridY >= 40 )
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}
						break;
					case 3 :
						UpdateObjectCoordinates2(&object->rotate,  
							&object->position, &object->coord);

						SortObjectSize(object);

							 
						object->rotate.vx += object->twist.vx;
						object->rotate.vy += object->twist.vy;
						object->rotate.vz += object->twist.vz;

							 
						object->position.vx += object->velocity.vx;
						object->position.vy += object->velocity.vy;
						object->position.vz += object->velocity.vz;

							 
						if (object->movementMomentumFlag == 0 )
							{
							object->velocity.vx = 0;
							object->velocity.vy = 0;
							object->velocity.vz = 0;
							}
						if (object->rotationMomentumFlag == 0 )
							{
							object->twist.vx = 0;
							object->twist.vy = 0;
							object->twist.vz = 0;
							}

							 
						gridX = object->position.vx / 128 ;
						gridY = object->position.vz / 128 ;

							 
						if (object->lifeTime > 25)
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}

						if (worldmaps[gridX][gridY] == 0x01 )
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}

						if (gridX < 0 || gridX >= 40 
							|| gridY < 0 || gridY >= 40 )
							{
							object->alive = 0 ;
							object->lifeTime = 0;
							}
						break;
					case 2 :
						HandleEnemyBehaviour(object);

						object->rotate.vx += object->twist.vx;
						object->rotate.vy += object->twist.vy;
						object->rotate.vz += object->twist.vz;

							 
						UpdateObjectCoordinates3 (&object->rotate, &object->twist,
							&object->position, &object->velocity,
							&object->coord);

						SortObjectSize(object);

						{	if (( object->position.vx ) < (  0 ))	( object->position.vx ) = (  0 );	else if (( object->position.vx ) > (  40 * 128  ))	( object->position.vx ) = (  40 * 128  );	} ;
						{	if (( object->position.vz ) < (  0 ))	( object->position.vz ) = (  0 );	else if (( object->position.vz ) > (  40 * 128  ))	( object->position.vz ) = (  40 * 128  );	} ;

							 
						if (object->movementMomentumFlag == 0 )
							{
							object->velocity.vx = 0;
							object->velocity.vy = 0;
							object->velocity.vz = 0;
							}
						if (object->rotationMomentumFlag == 0 )
							{
							object->twist.vx = 0;
							object->twist.vy = 0;
							object->twist.vz = 0;
							}
								
						if (object->currentHealth < 1)
							HandleEnemysDeath(object);
						break;
					default:
						( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	1784, "tuto7.c"), exit(1), 0) ) ;
					}
				}
			}
		}

endOfHandleAllObjects:
	;
}




VECTOR realMovement;
MATRIX xMatrix, yMatrix, zMatrix;
SVECTOR xVector, yVector, zVector;



	 
void UpdateObjectCoordinates (VECTOR* twist,
							VECTOR* position, VECTOR* velocity,
							GsCOORDINATE2* coordSystem, MATRIX* matrix)
{	
		 
	ApplyMatrixLV(matrix, velocity, &realMovement);
	
		 
	position->vx += realMovement.vx;
	position->vy += realMovement.vy;
	position->vz += realMovement.vz;


	xVector.vx = twist->vx;
	xVector.vy = 0;
	xVector.vz = 0;
	yVector.vx = 0;
	yVector.vy = twist->vy;
	yVector.vz = 0;
	zVector.vx = 0;
	zVector.vy = 0;
	zVector.vz = twist->vz;

	RotMatrix(&xVector, &xMatrix);
	RotMatrix(&yVector, &yMatrix);
	RotMatrix(&zVector, &zMatrix);

		 
		 

	MulMatrix0(matrix, &xMatrix, matrix);
	MulMatrix0(matrix, &yMatrix, matrix);
	MulMatrix0(matrix, &zMatrix, matrix);

	coordSystem->coord = *matrix;
	
		 
	coordSystem->coord.t[0] = position->vx;
	coordSystem->coord.t[1] = position->vy;
	coordSystem->coord.t[2] = position->vz;

		 
	coordSystem->flg = 0;
}






MATRIX tempMatrix;

	 
void UpdateObjectCoordinates2 (SVECTOR* rotationVector,
							VECTOR* translationVector,
							GsCOORDINATE2* coordSystem)
{
		 
	RotMatrix(rotationVector, &tempMatrix);

		 
	coordSystem->coord = tempMatrix;
	
		 
	coordSystem->coord.t[0] = translationVector->vx;
	coordSystem->coord.t[1] = translationVector->vy;
	coordSystem->coord.t[2] = translationVector->vz;

		 
	coordSystem->flg = 0;
}




VECTOR realMovement;


	 
void UpdateObjectCoordinates3 (SVECTOR* rotation, VECTOR* twist,
							VECTOR* position, VECTOR* velocity,
							GsCOORDINATE2* coordSystem)
{ 
	int gridX, gridY;

		 
	tempMatrix.t[0] = coordSystem->coord.t[0];
	tempMatrix.t[1] = coordSystem->coord.t[1];
	tempMatrix.t[2] = coordSystem->coord.t[2];

		 
	RotMatrix(rotation, &tempMatrix);

		 
	ApplyMatrixLV(&tempMatrix, velocity, &realMovement);
	   
		 
	coordSystem->coord = tempMatrix;
	

	if (CollisionWithWalls(position, &realMovement) == 0 )
		{
			 
		position->vx += realMovement.vx;
		position->vy += realMovement.vy;
		position->vz += realMovement.vz;
		} 


# 1931 "tuto7.c"

  
		 
	coordSystem->coord.t[0] = position->vx;
	coordSystem->coord.t[1] = position->vy;
	coordSystem->coord.t[2] = position->vz;

		 
	coordSystem->flg = 0;
}




	 


int CollisionWithWalls (VECTOR* position, VECTOR* movement)
{
	int result;
	CUBOID cuboid;

	( &cuboid )->  position->vx  = (  position->vx ),	( &cuboid )->  position->vy  = (  position->vy ),	( &cuboid )->  position->vz  = (  position->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx + movement->vx  = (  position->vx + movement->vx ),	( &cuboid )->  position->vy  = (  position->vy ),	( &cuboid )->  position->vz  = (  position->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx  = (  position->vx ),	( &cuboid )->  position->vy + movement->vy  = (  position->vy + movement->vy ),	( &cuboid )->  position->vz  = (  position->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx  = (  position->vx ),	( &cuboid )->  position->vy  = (  position->vy ),	( &cuboid )->  position->vz + movement->vz  = (  position->vz + movement->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx + movement->vx  = (  position->vx + movement->vx ),	( &cuboid )->  position->vy + movement->vy  = (  position->vy + movement->vy ),	( &cuboid )->  position->vz  = (  position->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx + movement->vx  = (  position->vx + movement->vx ),	( &cuboid )->  position->vy  = (  position->vy ),	( &cuboid )->  position->vz + movement->vz  = (  position->vz + movement->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	( &cuboid )->  position->vx  = (  position->vx ),	( &cuboid )->  position->vy + movement->vy  = (  position->vy + movement->vy ),	( &cuboid )->  position->vz + movement->vz  = (  position->vz + movement->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;


	( &cuboid )->  position->vx + movement->vx  = (  position->vx + movement->vx ),	( &cuboid )->  position->vy + movement->vy  = (  position->vy + movement->vy ),	( &cuboid )->  position->vz + movement->vz  = (  position->vz + movement->vz ),	( &cuboid )->  
						(128 )   = (   						(128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ),	( &cuboid )->  (128 )   = (  (128 )  ) ;
	if (NotSafe(&cuboid))
		return 1 ;

	return 0 ;

	


# 2024 "tuto7.c"

}
	





int NotSafe (CUBOID* cuboid)
{
	int gridX, gridY, gridZ;
	
	if ( (cuboid->x < 128 /2)
		|| (cuboid->y < 128 /2)
		|| (cuboid->z < 128 /2)
		|| (cuboid->x + cuboid->w + 128 /2 > (40 -1)* 128 )
		|| (cuboid->y + cuboid->h + 128 /2 > (40 -1)* 128 )
		|| (cuboid->z + cuboid->d + 128 /2 > (40 -1)* 128 ) )
			return 1 ;


	gridX = (cuboid->x) / 128 ;
	gridY = (cuboid->y) / 128 ;
	gridZ = (cuboid->y) / 128 ;

	if ((gridX >= 0 && gridX < 40 ) == 0 )
		return 1 ;
	if ((gridY >= 0 && gridY < 40 ) == 0 )
		return 1 ;
	if ((gridZ >= 0 && gridZ < 40 ) == 0 )
		return 1 ;

	if (worldmaps[gridX][gridY][gridZ] & 0x01 )
		return 1 ;

	



	return 0 ;




# 2126 "tuto7.c"

}







void InitialiseView( void )
{
	GsSetProjection(192);	 


	PVect.vx = PVect.vy = PVect.vz = 0;

# 2150 "tuto7.c"


	ReferenceDistance = 50;
	ViewpointZDistance = 220;
	ViewpointYDistance = -40;


	view.vrx = 0; view.vry = 0; view.vrz = 0;  
	view.vpx = 0; view.vpy = ViewpointYDistance; view.vpz = ViewpointZDistance;
	view.rz = 0;
	view.super = &PlayersShip.coord;


	GsSetRefView2(&view);
}





 
void InitialiseLighting(void)
{
	 
	TheLights[0].vx = 1; TheLights[0].vy= 1; TheLights[0].vz= 1;

	TheLights[0].r = TheLights[0].g = TheLights[0].b = 0x80;

	GsSetFlatLight(0, &TheLights[0]);


	 
	TheLights[1].vx = -1; TheLights[1].vy= -1; TheLights[1].vz= 1;

	TheLights[1].r = TheLights[1].g = TheLights[1].b = 0x80;

	GsSetFlatLight(1, &TheLights[1]);



	GsSetAmbient(4096 /4, 4096 /4, 4096 /4);




	lightmode = 1;	  
	GsSetLightMode(lightmode);


		 
	fogparam.dqa = -960;
	fogparam.dqb = 5120*5120;
		 
	fogparam.rfc = 0; fogparam.gfc = 0; fogparam.bfc = 4;
	GsSetFogParam(&fogparam);
}





 
int InitialiseTexture(long addr)
{
	RECT rect;
	GsIMAGE tim1;

	 
	GsGetTimInfo((u_long *)(addr+4),&tim1);

	rect.x=tim1.px;	 
	rect.y=tim1.py;	 
	rect.w=tim1.pw;	 
	rect.h=tim1.ph;	 

	 
	LoadImage(&rect,tim1.pixel);
	 
	if((tim1.pmode>>3)&0x01) {
		rect.x=tim1.cx;	 
		rect.y=tim1.cy;	 
		rect.w=tim1.cw;	 
		rect.h=tim1.ch;	 
		 
		LoadImage(&rect,tim1.clut);
	}
	DrawSync(0);
	return(0);
}



long* InitialiseModel( long* adrs )
{
	long *dop;

	dop=adrs;
	dop++;
	GsMapModelingData(dop);
	dop++;
	dop++;
	return( dop );
}








void make_world_maps( void )
{
	int	x, y, z;
	int	fact;

		 
		 
	fact = 128 ;
	for( x=0; x< 40 ; x++ ) 
		{		
		for( y=0; y< 40 ; y++ )
			{
			for( z=0; z< 40 ; z++ ) 
				{
				worldmaps[x][y][z] = (rand()%24==0)?0x01 :0;
				}
			}
		}

		 
		 
	for( x=0; x< 40 ; x++ ) 
		{
		for( y=0; y< 40 ; y++ ) 
			{
			for( z=0; z< 40 ; z++ ) 
				{
				GsInitCoordinate2(0  , &World[x][y][z]);
				World[x][y][z].coord.t[0] = x*fact;
				World[x][y][z].coord.t[1] = y*fact;
				World[x][y][z].coord.t[2] = z*fact;
				}
			}
		}
}


   

  


void PrintObject (ObjectHandler* object)
{
	printf("id: %d, alive: %d, type: %d, which: %d\n",
		object->id, object->alive, object->type, object->which);

	printf("GsDOBJ2: attribute %d\n", ( &object->handler )->attribute),	printf("GsDOBJ2: coord pointer %u\n", (u_long)( &object->handler )->coord2),	printf("GsDOBJ2: tmd pointer %u\n", (u_long)( &object->handler )->tmd),	printf("GsDOBJ2: id %d\n", ( &object->handler )->id) ;
	printf("model: addr %u, which one %d\n",
		object->modelAddress, object->whichModel);

	printf("scaling flag: %d\n", object->scalingFlag);
	printf("VECTOR: %d, %d, %d\n",	( &object->scalingVector )->vx, ( &object->scalingVector )->vy, ( &object->scalingVector )->vz) ;

	printf("movementTypeFlag: %d\n", object->movementTypeFlag);

	printf("VECTOR: %d, %d, %d\n",	( &object->position )->vx, ( &object->position )->vy, ( &object->position )->vz) ;
	printf("VECTOR: %d, %d, %d\n",	( &object->velocity )->vx, ( &object->velocity )->vy, ( &object->velocity )->vz) ;
	printf("movement momentum: %d\n",
		object->movementMomentumFlag);
		
	printf("VECTOR: %d, %d, %d\n",	( &object->rotate )->vx, ( &object->rotate )->vy, ( &object->rotate )->vz) ;
	printf("VECTOR: %d, %d, %d\n",	( &object->twist )->vx, ( &object->twist )->vy, ( &object->twist )->vz) ;
	printf("rotation momentum: %d\n",
		object->rotationMomentumFlag); 

	printf("GsCOORDINATE2: flg: %d\n", ( &object->coord )->flg),	printf("GsCOORDINATE2: coord.m: [0]: %d, %d, %d\n[1]: %d, %d, %d\n[2]: %d, %d, %d\n",	( &object->coord )->coord.m[0][0], ( &object->coord )->coord.m[0][1], ( &object->coord )->coord.m[0][2], ( &object->coord )->coord.m[1][0], ( &object->coord )->coord.m[1][1], ( &object->coord )->coord.m[1][2],	( &object->coord )->coord.m[2][0], ( &object->coord )->coord.m[2][1], ( &object->coord )->coord.m[2][2]),	printf("GsCOORDINATE2: coord.t: %d %d %d\n", ( &object->coord )->coord.t[0], ( &object->coord )->coord.t[1], ( &object->coord )->coord.t[2]),	printf("GsCOORDINATE2: super pointer: %u\n", ((u_long)( &object->coord )->super)) ;
	printf("super coord object id: %d\n",
		object->superCoordinateObjectID);
	printf("MATRIX: m: [0]: %d, %d, %d\n[1]: %d, %d, %d\n[2]: %d, %d, %d\n",	( &object->matrix )->m[0][0], ( &object->matrix )->m[0][1], ( &object->matrix )->m[0][2], ( &object->matrix )->m[1][0], ( &object->matrix )->m[1][1], ( &object->matrix )->m[1][2], ( &object->matrix )->m[2][0], ( &object->matrix )->m[2][1], ( &object->matrix )->m[2][2]),	printf("MATRIX: t: %d %d %d\n", ( &object->matrix )->t[0], ( &object->matrix )->t[1], ( &object->matrix )->t[2]) ;

	printf("inOrbit: %d, centralBodyID: %d\n, 		angle: %d, angleIncrement: %d\n",

		object->inOrbit, object->centralBodyID,
		object->angle, object->angleIncrement);
	printf("whichWay: %d, radius: %d\n",
		object->whichWay, object->radius);
	printf("VECTOR: %d, %d, %d\n",	( &object->firstVector )->vx, ( &object->firstVector )->vy, ( &object->firstVector )->vz) ;
	printf("VECTOR: %d, %d, %d\n",	( &object->secondVector )->vx, ( &object->secondVector )->vy, ( &object->secondVector )->vz) ;

	printf("specialMovement: %d\n", object->specialMovement);

	printf("initialHealth: %d\n", object->initialHealth);
	printf("currentHealth: %d\n", object->currentHealth);

	printf("strategyFlag: %d\n", object->strategyFlag);

	printf("meritRating: %d\n", object->meritRating);
}





	 
void PositionSomewhereNotInAWall (ObjectHandler* object)
{
	int gridX, gridY, gridZ;
	int xOffset, yOffset, zOffset;
	int success = 0 ;

	for (;;)
		{			 
		gridX = rand() % 40 ;
		gridY = rand() % 40 ;
		gridZ = rand() % 40 ;

		if (worldmaps[gridX][gridY][gridZ] != 0x01 )
			{
			success = 1 ;
			break;
			}
		}

	( ( success == 1  ) ? 1 :	( printf("Assertion failure! " "success == TRUE"	"At line %d of file '%s'.\n",	2375, "tuto7.c"), exit(1), 0) ) ;			 

		 
	xOffset = 128 /4 + (rand() % (128 /2));
	yOffset = 128 /4 + (rand() % (128 /2));
	zOffset = 128 /4 + (rand() % (128 /2));

	object->position.vx = (128  * gridX) + xOffset;
	object->position.vy = (128  * gridY) + yOffset;
	object->position.vz = (128  * gridZ) + zOffset;



# 2421 "tuto7.c"

}

	  



	 
void HandleEnemyBehaviour (ObjectHandler* object)
{
	object->framesSinceLastFire++;

	switch(object->strategyFlag)
		{
		case 0 :	 			
			HandleWaitingShipsBehaviour(object);
			break;
		case 1 :				
			HandleStationaryTrackingShipsBehaviour(object);
			break;
		case 2 :
			HandleSeekingShipBehaviour(object);
			break;
		case 3 :
			HandleRandomShipsBehaviour(object);
			break;
		default:
			( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	2448, "tuto7.c"), exit(1), 0) ) ;
		}
}





void HandleWaitingShipsBehaviour (ObjectHandler* object)
{
	int x, z;

		 
		 

	x = PlayersShip.position.vx - object->position.vx;
	z = PlayersShip.position.vz - object->position.vz;

	if (abs(x) < 500 && abs(z) < 500)
		{
		printf("activating sleeper\n");
		object->strategyFlag = 2 ;
		}

	if (object->lifeTime > object->specialTimeLimit)
		{
		printf("activating sleeper\n");
		object->strategyFlag = 2 ;
		}
}





void HandleStationaryTrackingShipsBehaviour (ObjectHandler* object)
{
	int x, z;
	int turnAngle, positionalAngle;

		 
		 
		
	x = PlayersShip.position.vx - object->position.vx;
	z = PlayersShip.position.vz - object->position.vz;

	positionalAngle = SUBratan(x,z);
	positionalAngle += 2048;
	positionalAngle &= 4095;
	turnAngle = positionalAngle - object->rotate.vy;
			
	if (abs(turnAngle) >= 57)	 
		{
		if (turnAngle >= 0)			  
			object->twist.vy += (object->rotationSpeed << 2);	   
		else						  
			object->twist.vy -= (object->rotationSpeed << 2);
		}
	else			 
		{
		if (abs(x) < 500 && abs(z) < 500)	  
			{
			if (object->framesSinceLastFire > object->firingRate)			 
				{
				EnemyShipFiresAShot(object);
				object->framesSinceLastFire = 0;
				}
			}
		}
}






	 
void HandleSeekingShipBehaviour (ObjectHandler* object)
{
	int x, z;
	int turnAngle, positionalAngle;
		
	x = PlayersShip.position.vx - object->position.vx;
	z = PlayersShip.position.vz - object->position.vz;

	positionalAngle = SUBratan(x,z);
	positionalAngle += 2048;
	positionalAngle &= 4095;
	turnAngle = positionalAngle - object->rotate.vy;
			
		 
	if (abs(turnAngle) >= 114)	 
		{
		if (turnAngle >= 0)			  
			object->twist.vy += (object->rotationSpeed << 2);	   
		else						  
			object->twist.vy -= (object->rotationSpeed << 2);
		}
	else			 
		{		  
		if (abs(x) > 500 && abs(z) > 500)	    
			object->velocity.vz -= object->movementSpeed;
		else if (abs(x) < 250 && abs(z) < 250)	    
			object->velocity.vz += object->movementSpeed;

		if (abs(x) < 500 && abs(z) < 500)	  
			{
			if (object->framesSinceLastFire > object->firingRate)			 
				{
				EnemyShipFiresAShot(object);
				object->framesSinceLastFire = 0;
				}
			}
		}
}





void HandleRandomShipsBehaviour (ObjectHandler* object)
{
	int whichRandomAction;

	if (object->lifeTime % object->specialTimeLimit == 0
		|| object->currentActionFlag == 1001 )		 
		{
		whichRandomAction = rand() % 5 ;

		switch(whichRandomAction)
			{
			case 0:
				object->currentActionFlag = 0 ;
				break;
			case 1:
				object->currentActionFlag = 1 ;
				break;
			case 2:
				object->currentActionFlag = 2 ;
				break;
			case 3:
				object->currentActionFlag = 3 ;
				break;
			case 4:
				object->currentActionFlag = 4 ;
				break;
			}
		}
	else
		{		    
		switch(object->currentActionFlag)
			{
			case 0 :
				object->twist.vy -= object->rotationSpeed << 2;
				break;
			case 1 :
				object->twist.vy += object->rotationSpeed << 2;
				break;
			case 2 :
				object->velocity.vz += object->movementSpeed << 2;
				break;
			case 3 :
				object->velocity.vz -= object->movementSpeed << 2;
				break;
			case 4 :
				if (object->framesSinceLastFire > object->firingRate)			 
					{
					EnemyShipFiresAShot(object);
					object->framesSinceLastFire = 0;
					}
				break;
			default:
				( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	2620, "tuto7.c"), exit(1), 0) ) ;
			}
		}
}
					
			



			 
void HandlePlayersDeath (void)
{
	 
	ExplodeObject(&PlayersShip);
	
	 

	sprintf(TextStrings[0], "You have died\n");
	sprintf(TextStrings[1], "Your score: %d\n", PlayersShip.meritRating);
	sprintf(TextStrings[2], "Press start\nto play again\n");

	DummyGuiLoopForTextPrinting(3, (1<<11)  );

	ResetAll();

	PlayersShip.currentHealth = 10;
	PlayersShip.alive = 1 ;
}




void HandleEnemysDeath (ObjectHandler* object)
{
	PlayersShip.meritRating 
		+= (object->initialHealth * (object->strategyFlag + 1));

	ExplodeObject(object);
}





	 
int CheckCollisions (void)
{
	ObjectHandler* object;
	int i, j;

	for (i = 0; i < 20 ; i++)
		{
		if (TheShips[i].alive == 1 )
			{
			if (ObjectsVeryClose(&TheShips[i], &PlayersShip))
				{
					 
				 
				PlayersShip.currentHealth--;
				TheShips[i].currentHealth--;
				}
			}
		}

	for (i = 0; i < 50 ; i++)
		{
		if (TheBullets[i].alive == 1  && TheBullets[i].allegiance == 2 )
			{
			if (ObjectsVeryClose(&TheBullets[i], &PlayersShip))
				{
					 
				 
				PlayersShip.currentHealth--;
				}
			}
		} 

	for (i = 0; i < 20 ; i++)
		{
		if (TheShips[i].alive == 1 )
			{
			for (j = 0; j < 50 ; j++)
				{
				if (TheBullets[j].alive == 1  && TheBullets[j].allegiance == 0 )
					{
					if (ObjectsVeryClose(&TheBullets[j], &TheShips[i]))
						{
							 
						 
						 
						TheShips[i].currentHealth--;
						}
					}
				}
			}
		}
}


	  





int ObjectsVeryClose (ObjectHandler* first, ObjectHandler* second)
{
	if (abs(first->position.vx - second->position.vx) > 50)
		return 0 ;
	if (abs(first->position.vy - second->position.vy) > 50)
		return 0 ;
	if (abs(first->position.vz - second->position.vz) > 50)
		return 0 ;

	return 1 ; 
}





void ExplodeObject (ObjectHandler* object)
{
	int cubeID;
	int whichAxis, sign;
	int i, j;
	
	object->alive = 0 ;

		 
	for (i = 0; i < 6; i++)
		{
		cubeID = -1;	

			 
		for (j = 0; j < 20 ; j++)
			{
			if (TheCubes[j].alive == 0 )
				{
				cubeID = j;
				break;
				}
			}

		if (cubeID == -1)		 
			continue;
		else
			{
			TheCubes[cubeID].alive = 1 ;
			TheCubes[cubeID].lifeTime = 0;

				 
			TheCubes[cubeID].rotationMomentumFlag = 1 ;
			TheCubes[cubeID].twist.vx = rand() % 80;
			TheCubes[cubeID].twist.vy = rand() % 80;
				
				 
			TheCubes[cubeID].position.vx = object->position.vx;
			TheCubes[cubeID].position.vy = object->position.vy;
			TheCubes[cubeID].position.vz = object->position.vz;

			whichAxis = i/2;
			if (i%2 == 0)
				sign = 1;
			else
				sign = -1;

				 
				 
			TheCubes[cubeID].movementMomentumFlag = 1 ;
			TheCubes[cubeID].velocity.vx = sign * (object->coord.coord.m[whichAxis][0] >> 9);
			TheCubes[cubeID].velocity.vy = sign * (object->coord.coord.m[whichAxis][1] >> 9);
			TheCubes[cubeID].velocity.vz = sign * (object->coord.coord.m[whichAxis][2] >> 9); 
			}
		}
}



   	

	 
	 
	 

void DummyGuiLoopForTextPrinting (int numberOfStrings, int quitKey)
{
	int	i;
	int	hsync = 0;
	GsDOBJ2 *op;
	int side;			   
	int localFrameCounter = 0;
	long pad;

	side = GsGetActiveBuff();

	for (;;)
		{
		localFrameCounter++;

		pad = PadRead(0);

		if (pad & quitKey && localFrameCounter > 60)
			break;		 
	  
		GsSetWorkBase((PACKET*)packetArea[side]);
		GsClearOt(0,0,&Wot[side]);
		GsClearOt(0,0,&Sot[side]);
		
		hsync = VSync(2);
		ResetGraph(1);
		GsSwapDispBuff();
		GsSortClear(0,0,4,&Wot[side]);
		GsDrawOt(&Wot[side]);
		GsDrawOt(&Sot[side]);
		side ^= 1;

		for (i = 0; i < numberOfStrings; i++)
			{
			FntPrint(TextStrings[i]);
			}
		
		FntFlush(-1);
		}	
}





	 
	 
	 
void ResetAll (void)
{
	int i;

		 
	make_world_maps();

	PlayersShip.velocity.vx = 0;
	PlayersShip.velocity.vy = 0;
	PlayersShip.velocity.vz = 0;
	PlayersShip.twist.vx = 0;
	PlayersShip.twist.vy = 0;
	PlayersShip.twist.vz = 0;
	PlayersShip.rotate.vx = 0;
	PlayersShip.rotate.vy = 0;
	PlayersShip.rotate.vz = 0;

	PositionSomewhereNotInAWall(&PlayersShip);
	PlayersShip.allegiance = 0 ;
	PlayersShip.position.vy = 20;

	PlayersShip.movementSpeed = 48;
	PlayersShip.rotationSpeed = 60;
	PlayersShip.firingRate = 5;
	PlayersShip.framesSinceLastFire = 0;

		

	for (i = 0; i < 50 ; i++)
		{
		BringObjectToLife(&TheBullets[i], 1 , 
			0x80097000 , 0, 1001 );

		SetObjectScaling(&TheBullets[i], 4096 >>5, 4096 >>5, 4096 >>5);

		TheBullets[i].velocity.vx = 0;
		TheBullets[i].velocity.vy = 0;
		TheBullets[i].velocity.vz = 0;
		TheBullets[i].twist.vx = 0;
		TheBullets[i].twist.vy = 0;
		TheBullets[i].twist.vz = 0;
		TheBullets[i].rotate.vx = 0;
		TheBullets[i].rotate.vy = 0;
		TheBullets[i].rotate.vz = 0;

		TheBullets[i].position.vy = 20;
		}


	for (i = 0; i < 20 ; i++)
		{
		TheCubes[i].velocity.vx = 0;
		TheCubes[i].velocity.vy = 0;
		TheCubes[i].velocity.vz = 0;
		TheCubes[i].twist.vx = 0;
		TheCubes[i].twist.vy = 0;
		TheCubes[i].twist.vz = 0;
		TheCubes[i].rotate.vx = 0;
		TheCubes[i].rotate.vy = 0;
		TheCubes[i].rotate.vz = 0;

		BringObjectToLife(&TheCubes[i], 3 , 
			0x80097000 , 0, 1001 );

		SetObjectScaling(&TheCubes[i], 4096 >>3, 4096 >>3, 4096 >>3);
		TheCubes[i].position.vy = 20;
		}




	for (i = 0; i < 20 ; i++)
		{
		TheShips[i].velocity.vx = 0;
		TheShips[i].velocity.vy = 0;
		TheShips[i].velocity.vz = 0;
		TheShips[i].twist.vx = 0;
		TheShips[i].twist.vy = 0;
		TheShips[i].twist.vz = 0;
		TheShips[i].rotate.vx = 0;
		TheShips[i].rotate.vy = 0;
		TheShips[i].rotate.vz = 0;

		BringObjectToLife(&TheShips[i], 2 , 
			0x80096000 , 0, 1001 );

		TheShips[i].initialHealth = 1;
		TheShips[i].currentHealth = 1;
			 
		TheShips[i].strategyFlag = rand() % 4 ;
		InitialiseShipAccordingToStrategy(&TheShips[i]);

		PositionSomewhereNotInAWall(&TheShips[i]);
		TheShips[i].allegiance = 2 ;

		TheShips[i].position.vy += 20;
		}




	for (i = 0; i < 50 ; i++)
		{
		TheBullets[i].alive = 0 ;		 
		}
	for (i = 0; i < 20 ; i++)
		{
		TheCubes[i].alive = 0 ;		 
		}	



	InitialiseView();
	InitialiseLighting();


	MainMode = 1 ;
}







void HandleLevelTransition (void)
{
	int levelBonus;

	levelBonus = LevelNumber * 50;
	LevelNumber++;			 

	PlayersShip.meritRating += levelBonus;

	sprintf(TextStrings[0], "Finished level %d\n", LevelNumber-1);
	sprintf(TextStrings[1], "level bonus: %d\n", levelBonus);
	sprintf(TextStrings[2], "Your score: %d\n", PlayersShip.meritRating);
	sprintf(TextStrings[3], "Press start for\nthe next level\n");

	DummyGuiLoopForTextPrinting(4, (1<<11)  );

	ResetAll();
}

	



int FindDirectionToNearestLivingEnemy (int* exactDirection)
{
	int direction;
	int shipID;
	int x, y, z;
	int relativeX, relativeZ;
	int distanceSquared, minDistanceSquared, firstFlag = 1 ;
	int turnAngle, positionalAngle;
	int simplerAngle;
	int i;

	x = PlayersShip.position.vx;
	y = PlayersShip.position.vy;
	z = PlayersShip.position.vz;
	shipID = -1;
	for (i = 0; i < 20 ; i++)
		{
		if (TheShips[i].alive == 1 )
			{
			distanceSquared 
				= pow((x - TheShips[i].position.vx), 2)
				+ pow((y - TheShips[i].position.vy), 2)
				+ pow((z - TheShips[i].position.vz), 2);

			if (firstFlag == 1 )
				{
				shipID = i;
				minDistanceSquared = distanceSquared;
				firstFlag = 0 ;
				}
			else
				{
				if (distanceSquared < minDistanceSquared)
					{
					shipID = i;
					minDistanceSquared = distanceSquared;
					}
				}
			}
		}

	if (shipID == -1)
		{
		printf("FOUND NO SHIPS\n");
		direction = 1001 ;
		}
	else
		{
		relativeX = TheShips[shipID].position.vx - x;
		relativeZ = TheShips[shipID].position.vz - z;

		positionalAngle = SUBratan(relativeX, relativeZ);
		positionalAngle += 2048;
		positionalAngle &= 4095;
		turnAngle = positionalAngle - PlayersShip.rotate.vy;
		for (;;)
			{
			if (turnAngle >= 2049)
				turnAngle -= 4096;
			else if (turnAngle <= -2048)
				turnAngle += 4096;
			else
				break;
			}
		( ( turnAngle <= 2048 ) ? 1 :	( printf("Assertion failure! " "turnAngle <= 2048"	"At line %d of file '%s'.\n",	3065, "tuto7.c"), exit(1), 0) ) ;
		( ( turnAngle >= -2047 ) ? 1 :	( printf("Assertion failure! " "turnAngle >= -2047"	"At line %d of file '%s'.\n",	3066, "tuto7.c"), exit(1), 0) ) ;

		*exactDirection = turnAngle;

		simplerAngle = turnAngle >> 8;		 






		switch(simplerAngle)
			{
			case 0: 
			case 1: 
			case -1:
				direction = 0 ;
				break;
			case 2:
				direction = 1 ;
				break;
			case 3: 
			case 4: 
			case 5:
				direction = 2 ;
				break;
			case 6:
				direction = 3 ;
				break;
			case 7: 
			case 8:
			case -7:
			case -8:
				direction = 4 ;
				break;
			case -2:
				direction = 7 ;
				break;
			case -3:
			case -4:
			case -5:
				direction = 6 ;
				break;
			case -6:
				direction = 5 ;
				break;
			default:
				 
				( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	3114, "tuto7.c"), exit(1), 0) ) ;
			}
		}

	return direction;
}




void PrintCompassDirectionToNearestEnemy (int direction)
{
	if (direction == 1001 )
		return;

	switch(direction)
		{
		case 0 :
			FntPrint("north\n");
			break;
		case 1 :
			FntPrint("north-west\n");
			break;
		case 2 :
			FntPrint("west\n");
			break;
		case 3 :
			FntPrint("south-west\n");
			break;
		case 4 :
			FntPrint("south\n");
			break;
		case 5 :
			FntPrint("south-east\n");
			break;
		case 6 :
			FntPrint("east\n");
			break;
		case 7 :
			FntPrint("north-east\n");
			break;
		default:
			( ( 0  ) ? 1 :	( printf("Assertion failure! " "FALSE"	"At line %d of file '%s'.\n",	3156, "tuto7.c"), exit(1), 0) ) ;
		}
}

